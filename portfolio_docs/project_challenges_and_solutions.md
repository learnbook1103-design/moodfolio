# 🛠️ 주요 의사결정 및 기술 트러블슈팅 로그 (Key Decisions & Troubleshooting)

이 문서는 프로젝트 개발 과정에서 **기획 의도(User Idea)**를 기술적으로 구현하는 과정에서 발생한 문제점과 이를 해결한 과정을 상세히 기록합니다.

---

## 1. Mumu '도슨트' 모드 UX 최적화 (UX/Frontend)

### 💡 기획 의도 (User Decision)
> "채용 담당자가 포트폴리오를 볼 때, 일반 챗봇처럼 자유롭게 질문하게 두기보다 **우리가 원하는 순서대로 정보를 보여주는 '가이드(도슨트)'** 역할이 필요합니다. 채팅 입력창을 과감히 없애고 버튼 선택지로 유도합시다."

### 🚫 직면한 기술적 문제 (Challenge)
- **기존 구조의 한계**: 기존 `ChatWidget` 컴포넌트는 사용자의 텍스트 입력을 전제로 설계되어 있어, 입력창(`input`)을 단순히 CSS로 숨기면 로직 에러가 발생하거나 UX 흐름이 끊김.
- **비동기 처리 타이밍 이슈**: 버튼 클릭으로 미리 정의된 질문을 전송할 때, AI 응답이 오기 전에 사용자가 다른 행동을 하거나 위젯이 닫히면 `ReferenceError: data is not defined` 오류가 발생하여 앱이 멈추는 현상 발견.
- **스크롤 사용자 경험**: 버튼을 눌러 답변이 나왔는데, 사용자가 다시 스크롤을 올려야 다음 버튼을 누를 수 있는 불편함 발생.

### ✅ 해결 과정 (Solution)
1.  **입력 인터페이스 조건부 렌더링**: `isShared` (공유 뷰) 상태에 따라 입력창을 아예 DOM에서 제거하고, 대신 `SuggestedQuestions` 컴포넌트가 항상 하단에 고정되도록 레이아웃 재설계.
2.  **오토 스크롤 및 메뉴 재호출**: AI 답변이 완료(`isLoading: false`)되는 즉시 자동으로 다음 질문 선택지(메뉴)를 다시 렌더링하고, 화면을 최하단으로 부드럽게 스크롤(`scrollIntoView`)하여 사용자의 불필요한 조작을 제거.
3.  **예외 처리 강화**: 비동기 응답 처리부(`then/catch`)에서 `data` 객체의 존재 여부를 먼저 확인하는 방어 코드를 추가하여 런타임 에러 완전 차단.

---

## 2. 게스트 사용자 경험의 연속성 보장 (Onboarding Strategy)

### 💡 기획 의도 (User Decision)
> "사용자가 로그인 없이도 포트폴리오를 충분히 만들어볼 수 있어야 합니다(Guest Mode). 하지만 **체험 후 회원가입을 했을 때, 열심히 작성한 데이터가 날아가면 안 됩니다.** 자연스럽게 계정으려 이관되어야 합니다."

### 🚫 직면한 기술적 문제 (Challenge)
- **데이터 저장소의 파편화**: 게스트 데이터는 브라우저 `LocalStorage`에 저장되고, 회원 데이터는 `Supabase DB`에 저장됨. 두 저장소는 완전히 분리되어 있음.
- **이관 시점의 모호성**: 회원가입 직후인지, 로그인 직후인지, 혹은 소셜 로그인 리다이렉트 이후인지 이관 로직을 실행할 정확한 '트리거' 시점을 잡기 어려움.
- **데이터 충돌**: 만약 기존 계정에 이미 데이터가 있는데 게스트 상태에서 또 데이터를 만들고 로그인하면 어떻게 병합할 것인가?

### ✅ 해결 과정 (Solution)
1.  **마이그레이션 훅(Hook) 개발**: `useMigration` 커스텀 훅을 만들어 로그인 성공(`onAuthSuccess`) 이벤트 발생 시 즉시 로컬 데이터를 체크하도록 구현.
2.  **우선순위 로직 정립**:
    - 전략: **"게스트 데이터 우선 (Overwrite)"** 또는 **"병합(Merge)"** 중 사용자 혼란을 줄이기 위해, 신규 가입 시에는 무조건 게스트 데이터를 DB로 업로드(`Upsert`)하고 로컬을 비우는 방식 채택.
3.  **프로세스 자동화**: 사용자가 별도 버튼을 누를 필요 없이, `useEffect`를 통해 인증 상태 변화를 감지하여 백그라운드에서 조용히 데이터 이관 후 "데이터가 저장되었습니다" 토스트 메시지 노출.

---

## 3. 레거시 템플릿 운영 및 생명주기 관리 (Operations)

### 💡 기획 의도 (User Decision)
> "오래된 템플릿은 디자인이 별로라 신규 사용자는 선택 못 하게 하고 싶습니다. 하지만 **이미 그 템플릿으로 포트폴리오를 만든 기존 사용자들의 화면은 깨지면 안 됩니다.**"

### 🚫 직면한 기술적 문제 (Challenge)
- **하드코딩된 필터링**: 초기에는 코드 상에서 `if (id !== 'old_temp')` 처럼 하드코딩하여 관리했으나, 템플릿이 늘어날수록 배포 없이 설정을 바꾸기 불가능했음.
- **데이터 무결성**: 템플릿을 비활성화(Disable)한다고 해서 관련 컴포넌트 파일을 삭제해버리면, 기존 사용자의 포트폴리오 로딩 시 `Component Not Found` 에러 발생.

### ✅ 해결 과정 (Solution)
1.  **DB 기반 설정 관리**: Supabase에 `template_config` 테이블을 생성하여 각 템플릿 ID별 `is_active` 상태를 관리.
2.  **이원화된 렌더링 로직**:
    - **선택 화면(Selection Modal)**: `isActive === true`인 템플릿만 필터링하여 노출 (신규 진입 차단).
    - **결과 화면(Result Page)**: `isActive` 여부와 상관없이, 사용자의 포트폴리오 데이터에 저장된 `templateId`에 해당하는 컴포넌트를 그대로 렌더링 (기존 유지).
3.  **관리자 제어**: 관리자 대시보드에서 클릭 한 번으로 템플릿의 활성/비활성 상태를 즉시 토글할 수 있는 API 연동.

---

## 4. 데이터 정규화: 글로벌 프로필과 포트폴리오 분리 (Architecture)

### 💡 기획 의도 (User Decision)
> "포트폴리오를 여러 개 만들 수 있는데, **이름이나 자기소개 같은 기본 정보(Bio)를 매번 새로 입력하는 건 비효율적**입니다. 내 정보는 한 번만 입력하고 공통으로 쓰고 싶습니다."

### 🚫 직면한 기술적 문제 (Challenge)
- **JSON 구조의 중복**: 초기 설계는 하나의 거대한 JSON(`portfolio_data`) 안에 `name`, `email`, `projects`가 몽땅 들어있는 비정규화된 구조였음.
- **동기화 문제**: 사용자가 A 포트폴리오에서 이름을 수정했는데, B 포트폴리오에는 반영되지 않는 데이터 불일치 발생.

### ✅ 해결 과정 (Solution)
1.  **스키마 분리 (Normalization)**:
    - **`user_profiles` 테이블**: 이름, 이메일, 한줄 소개, 직무 등 변하지 않는 고유 정보 저장.
    - **`portfolios` 테이블**: 프로젝트 리스트, 선택한 템플릿, 테마 컬러 등 버전별로 달라지는 정보 저장.
2.  **마이그레이션 전략**: 기존의 거대 JSON에서 프로필 필드만 추출하여 `user_profiles` 테이블로 옮기는 데이터 마이그레이션 스크립트 실행.
3.  **API 응답 병합**: 클라이언트가 포트폴리오를 요청할 때, 백엔드에서 `Join` 연산(또는 애플리케이션 레벨 병합)을 수행하여 프론트엔드 수정 없이 온전한 데이터를 내려주도록 처리.

---

## 5. 백엔드 환경 변수 인코딩 (System Stability)

### 💡 기획 의도 (User Decision)
> "윈도우 사용자가 많은 국내 환경 특성상, 개발자가 **어떤 에디터(메모장, VS Code 등)로 .env를 수정해도 서버가 죽지 않아야** 합니다."

### 🚫 직면한 기술적 문제 (Challenge)
- **BOM(Byte Order Mark) 이슈**: 윈도우 메모장 등에서 저장 시 UTF-8 파일 헤더에 숨겨진 문자(BOM)가 붙어, 파이썬 라이브러리가 API Key 환경 변수명을 인식하지 못하는 치명적 오류 발생.

### ✅ 해결 과정 (Solution)
- 라이브러리(`python-dotenv`) 기본 동작에 의존하지 않고, 직접 파일을 읽어들이는 **BOM 인식 파서** 구현 (`encoding='utf-8-sig'`).
